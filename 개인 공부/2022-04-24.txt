레스터라이저 단계 준비하기
- RASTERIZER_DESC
  FillMode
  CullMode

뷰포트(Viewport) 설정
실제 화면의 어떤 영역에 Render Target이 출력되도록 하는지
UI등의 출력을 결정할 수 있다.

게임 프레임워크
CScene: 모든 게임 객체(CGameObject)를 소유한다.
CGameObject: 메쉬(CMesh)와 셰이더(CShader)를 소유한다.
CMesh: 메쉬를 그리는 방법
CShader: 메쉬를 어떻게 그릴 것인가. 셰이더에 대한 설정


Direct3D 리소스
- 모든 그래픽스 파이프라인 단계에는 리소스가 연결될 수 있음.
- 기하학적 데이터, 텍스처, 셰이더 데이터 등을 포함함
- GPU가 빠르게 접근할 수 있도록 비디오 메모리 영역에 저장되어야 함.
- 리소스는 크게 버퍼, 텍스처의 형식을 가짐

응용 프로그램에서 그래픽 카드의 비디오 메모리 내용을 읽는 연산은 엄청 느리다.
쓰는 것은 읽는 것보다는 빠르지만 그래도 느리다.
응용 프로그램에서 비디오 메모리 쪽으로 어떤 리소스를 전달하는 횟수를 가급적 줄여야 한다. (Batch 형태로 구성)
Set 함수의 사용 횟수(CPU에서 비디오 메모리로의 write) -> 가급적 줄여야 한다.


입력 조립 단계(Input Assembler Stage) 준비하기
1. 입력 버퍼(정점 버퍼 또는 인덱스 버퍼) 객체를 생성한다.
   CreateCommittedResource()
2. 입력 버퍼(정점 버퍼 또는 인덱스 버퍼)에 대한 뷰를 준비한다.
   D3D12_VERTEX_BUFFER_VIEW
   D3D12_INDEX_BUFFER_VIEW
3. 입력-레이아웃을 생성한다. 입력-레이아웃은 정점 버퍼의 한 원소의 구조를 나타낸다.
4. 입력 버퍼와 입력 레이아웃을 파이프라인 상태에 연결한다
5. 프리미티브 유형을 지정한다. IA-단계는 입력 데이터를 이 프리미티브 형태로 조립한다.
   (점을 그리는지, 선을 그리는지, 삼각형을 그리는지..)
6. 입력 버퍼 뷰를 입력-조립 단계에 연결한다
7. 그리기 함수를 호출한다. 이 그리기 함수의 호출로 그래픽스 파이프라인이 시작된다.

리소스의 갱신
map: 리소스의 사용 권한을 가져옴
unmap: 리소스의 사용 권한을 해제함.
 -D3D12_HEAP_TYPE_DEFAULT
- D3D12_HEAP_TYPE_UPLOAD
- D3D12_HEAP_TYPE_READBACK
  영구적 매핑을 허용하지 않음.

입력 레이아웃
- 입력 조립기 단계에 연결되는 입력 버퍼의 구조를 표현
- 정점 셰이더의 입력 시그니처와 일치해야 함
- 입력 버퍼의 모든 원소들은 같은 자료 구조를 가져야 함
- 입력 데이터는 하나 또는 여러 개의 버퍼로 표현되고 조립될 수 있음.

입력 레이아웃(Input layout Description)
정점 구조체의 각 필드, 즉 정점의 각 성분으로 무엇을 해야 하는지 Direct3D에게 알려줘야 한다.
D3D12_INPUT_LAYOUT_DESC 구조체를 담은 배열을 이용한다.


프리미티브 토폴로지(Primitive Topology)
- 파이프라인이 정점 버퍼의 데이터를 해석하는 방법을 나타냄
점들의 리스트, 선분들의 리스트, 선분들의 스트립, 삼각형들의 리스트, 삼각형들의 스트립..

프리미티브 토폴로지에 따라 DrawInstanced가 렌더링할 수 있는 적절한 정점을 넣어줘야 함
POINTLIST: n개의 정점 필요
LINELIST: 2*n개의 정점 필요
LINESTRIP: n+1개의 정점 필요
TRIANGLELIST: 3*n개의 정점 필요
TRIANGLESTRIP: n+2개의 정점 필요

정점 버퍼: 정점의 위치에 대한 정보
인덱스 버퍼: 실제 어떤 정점을 통해 프리미티브를 조립할지